module churchB where
type Bool :: * = forall x . x -> x -> x

primitive undefined :: forall a . a

true :: Bool
true = \ t f -> t

false :: Bool
false = \ t f -> f

type Pair ::  * -> * -> * = \ a b . forall x . (a -> b -> x) -> x

pair :: forall a b . a -> b -> Pair a b
pair x y = \ f -> f x y

fst :: forall a b . Pair a b -> a
fst = \ p -> p (\ a b -> a)

snd :: forall a b . Pair a b -> b
snd = \ p -> p (\ a b -> b)

type List :: * -> * =   \ a . forall x . x -> (a -> x -> x) -> x

nil :: forall a . List a
nil = \ n c -> n

cons :: forall a . a -> List a -> List a
cons = \ a as n c -> c a (as n c)

head :: forall a . List a -> a
head l = l undefined (\ a r -> a)

tail' :: forall a . List a -> (List a) 
tail' l =  fst (l (pair nil nil) (\ a r -> pair (snd r) (cons a (snd r))))

-- real :: forall a . List a -> List a
-- real l = fst (tail' l)

-- tail :: forall a . List a -> Pair (List a) (List a)
-- tail l = l (pair nil nil) (\ a r -> r (\ x y -> pair y (cons a y)))

type Braun :: * -> * =
  \ a . forall x . (a -> x) -> (x -> x -> x) -> x

leaf :: forall a . a -> Braun a
leaf = \ a l n -> l a

node :: forall a . Braun a -> Braun a -> Braun a
node left right = \ l n -> n (left l n) (right l n)

braunInsert :: forall a . a -> Braun a -> Braun a
braunInsert a b =
  snd (b (\ aa -> pair (leaf aa)
                       (node (leaf a) (leaf aa)))
         (\ pl pr -> pl (\ ll il -> pr (\ rr ir -> pair (node ll rr) (node ir ll)))))

toBraun :: forall a . a -> List a -> Braun a
toBraun a l = l (leaf a) (\ b r ->  braunInsert b r)

primitive merge :: forall a . (a -> a -> Bool) -> List a -> List a -> List a
-- merge f l1 l2 =

mergeSorth :: forall a . (a -> a -> Bool) -> Braun a -> List a
mergeSorth f t = t (\ a -> cons a nil) (\ l r -> merge f l r)

-- mergeSort :: forall a . (a -> a -> Bool) -> List a -> List a
-- mergeSort f l = let h = head l
--                     tl = tail l
--                 in mergeSorth f (toBraun h tl)
                
                       
