module church where

type Nat :: * = forall x . (x -> x) -> x -> x

zero :: Nat
zero = \ s z -> z
-- zero = \\ x . \ s : x -> x . \ z : x . z
succ :: Nat -> Nat
succ n = \ s z -> s (n s z)

one :: Nat
one = \ s z -> s z

add :: Nat -> Nat -> Nat
add n m = n succ m

mult :: Nat -> Nat -> Nat
mult = \ n m -> n (add m) zero

exp :: Nat -> Nat -> Nat
exp = \ n m -> n (mult m) one

add' :: Nat -> Nat -> Nat
add' n m = \ s z -> n s (m s z)


mult' :: Nat -> Nat -> Nat
mult' n m = \ s z -> n (m s) z

exp' :: Nat -> Nat -> Nat 
exp' n m = \ s z ->  (m n) s z
-- note that exp' n m = m n will not type check because application does not generalize variables

type Pair ::  * -> * -> * = \ a b . forall x . (a -> b -> x) -> x

pair :: forall a b . a -> b -> Pair a b
pair x y = \ f -> f x y

fst :: forall a b . Pair a b -> a
fst = \ p -> p (\ a b -> a)

snd :: forall a b . Pair a b -> b
snd = \ p -> p (\ a b -> b)

oneP :: Pair Nat Nat
oneP = pair one one

pred :: Nat -> Nat
pred n = fst (n (\ r -> pair (snd r) (succ (snd r))) (pair zero zero))

type List :: * -> * =   \ a . forall x . (a -> x -> x) -> x -> x

nil :: forall a . List a
nil = \ c n -> n

cons :: forall a . a -> List a -> List a
cons = \ a as c n -> c a (as c n)

tail :: forall a . List a -> (List a) 
tail l =  fst (l (\ a r -> pair (snd r) (cons a (snd r))) (pair nil nil))

