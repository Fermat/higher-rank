module List where

data List :: * -> * where
 Nil :: forall a . List a 
 Cons :: forall a . a -> List a -> List a

data Bool :: * where
 True :: Bool
 False :: Bool

data Nat :: * where
  Z :: Nat
  S :: Nat -> Nat

data Pair :: * -> * -> * where
  Pair :: forall a b . a -> b -> Pair a b
  
-- map :: forall a b . (a -> b) -> List a -> List b
-- map f Nil = Nil
-- map f (Cons x xs) = Cons (f x) (map f xs)

map' :: forall a b . (a -> b) -> List a -> List b
map' f l = case l of
       	   	Nil -> Nil
		Cons x xs -> Cons (f x) (map' f xs)

-- revapp :: forall a b . a -> (a -> b) -> b
-- revapp x f = f x

-- poly :: (forall v . v -> v) -> Pair Nat Bool
-- poly f = Pair (f Z) (f True)

-- test :: Pair Nat Bool
-- test = revapp (\ x -> x) poly

id :: forall x . x -> x
id = \ x -> x

-- f :: (forall a . List a -> List a) -> Pair (List Bool) (List Nat)
-- f x = Pair (x (Cons True (Cons False Nil))) (x (Cons Z (Cons (S Z) Nil)))


fix :: forall a . (a -> a) -> a
fix f = f (fix f)

data Term :: * -> * where
     Var :: forall a . a -> Term a
     App :: forall a . Term a -> Term a -> Term a
     Lam :: forall a . Term (Incr a) -> Term a

data Incr :: * -> * where
  Zero :: forall a . Incr a
  Succ :: forall a . a -> Incr a

mapI :: forall a b . (a -> b) -> Incr a -> Incr b
mapI f Zero = Zero
mapI f (Succ x) = Succ (f x)

mapT :: forall a b. (a -> b) -> Term a -> Term b
mapT = fix (\ mt -> \ f t -> 
       	     	       case t of
                           Var x -> Var (f x)
			   App t1 t2 -> App (mt f t1) (mt f t2)
			   Lam t -> Lam (mt (mapI f) t))


data Monad :: (* -> *) -> * where
  Mon :: forall m . (forall a . a -> m a) -> (forall a b . m a -> (a -> m b) -> m b) -> Monad m

return :: forall m . Monad m -> (forall a . a -> m a)
return (Mon r b) = r

bind :: forall m . Monad m -> (forall a b . m a -> (a -> m b) -> m b)
bind (Mon r b) = b




